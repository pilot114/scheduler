<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Планировщик</title>
    <link rel="manifest" href="manifest.json">
    <link rel="stylesheet" href="style.css">
    <script>
        // Apply theme before page loads
        const theme = localStorage.getItem('theme');
        if (theme === 'dark-mode') {
            document.documentElement.classList.add('dark-mode');
        }
    </script>
</head>
<body>
    <div class="header-container">
        <div class="container">
            <div class="header">
                <h1>Планировщик</h1>
                <div class="controls">
                    <button id="installPwaButton" style="display: none;">Установить</button>
                    <button id="settings-btn" class="settings-button">⚙️</button>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="main-content">
            <div class="calendar-section">
                <div class="month-selector">
                    <button onclick="changeMonth(-1)">◄</button>
                    <h2 id="currentMonth"></h2>
                    <button onclick="changeMonth(1)">►</button>
                </div>
                <table class="calendar" id="calendar">
                    <thead>
                        <tr>
                            <th>Пн</th>
                            <th>Вт</th>
                            <th>Ср</th>
                            <th>Чт</th>
                            <th>Пт</th>
                            <th>Сб</th>
                            <th>Вс</th>
                        </tr>
                    </thead>
                    <tbody id="calendarBody"></tbody>
                </table>
            </div>

            <div class="day-panel">
                <h3 id="selectedDate">Выберите день</h3>
                <ul class="task-list" id="taskList"></ul>
            </div>
            </div>
    </div>

    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <h2>Настройки</h2>
            <br>
            <div class="form-group">
                <label>Шаг выбора времени (в минутах)</label>
                <div class="radio-group">
                    <label><input type="radio" name="step" value="5"><span>5</span></label>
                    <label><input type="radio" name="step" value="10" checked><span>10</span></label>
                    <label><input type="radio" name="step" value="15"><span>15</span></label>
                    <label><input type="radio" name="step" value="30"><span>30</span></label>
                    <label><input type="radio" name="step" value="60"><span>60</span></label>
                </div>
            </div>
            <div class="form-group">
                <label for="theme-toggle-modal">Тёмная тема</label>
                <div class="theme-switcher">
                    <label class="switch">
                        <input type="checkbox" id="theme-toggle-modal">
                        <span class="slider round"></span>
                    </label>
                </div>
            </div>
            <div class="form-group">
                <label for="notifyButton-modal">Уведомления</label>
                <button id="notifyButton-modal">Включить уведомления</button>
            </div>
            <div class="form-group">
                <label>Данные</label>
                <div class="btn-group">
                    <button id="export-btn">Экспорт</button>
                    <button id="import-btn">Импорт</button>
                    <input type="file" id="import-file" style="display: none;" accept=".json">
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="taskModal">
        <div class="modal-content">
            <h3 id="modalTitle">Новое дело</h3>
            <form id="taskForm">
                <div class="form-group">
                    <input type="text" id="taskTitle" placeholder="Заголовок" required>
                </div>

                <div class="form-group">
                    <textarea id="taskDescription" placeholder="Описание"></textarea>
                </div>

                <div class="form-group">
                    <label for="taskTime">Время: <span id="timeLabel">00:00</span></label>
                    <input type="range" id="taskTime" min="0" max="1430" step="10" value="0" style="width: 100%;">
                </div>

                <div class="form-group">
                    <label for="taskDuration">Длительность: <span id="durationLabel">30 мин</span></label>
                    <input type="range" id="taskDuration" min="10" max="600" step="10" value="30" style="width: 100%;">
                </div>

                <div class="form-group" id="singleDateGroup">
                    <label>Дата</label>
                    <input type="date" id="taskDate">
                </div>

                <div class="form-group">
                    <div>
                        <label>
                            <input type="checkbox" id="taskRecurring" onchange="toggleRecurringOptions()">
                            Периодическое
                        </label>
                    </div>
                </div>

                <div class="recurring-options" id="recurringOptions">
                    <div class="form-group">
                        <label>Период повторения</label>
                        <select id="recurringType" onchange="toggleRecurringDetails()">
                            <option value="daily">Ежедневно</option>
                            <option value="weekly">Дни недели</option>
                            <option value="monthly">Дни месяца</option>
                        </select>
                    </div>

                    <div id="weeklyOptions" style="display: none; padding-bottom: 15px;">
                        <div class="weekdays-selector">
                            <label><span>Пн</span><input type="checkbox" value="1"></label>
                            <label><span>Вт</span><input type="checkbox" value="2"></label>
                            <label><span>Ср</span><input type="checkbox" value="3"></label>
                            <label><span>Чт</span><input type="checkbox" value="4"></label>
                            <label><span>Пт</span><input type="checkbox" value="5"></label>
                            <label><span>Сб</span><input type="checkbox" value="6"></label>
                            <label><span>Вс</span><input type="checkbox" value="0"></label>
                        </div>
                    </div>

                    <div id="monthlyOptions" style="display: none;">
                        <div class="monthly-options-grid">
                            <div class="form-group">
                                <label for="monthDays">Дни месяца (через запятую)</label>
                                <input type="text" id="monthDays" placeholder="1, 15, 31" value="1">
                            </div>
                            <div class="form-group checkbox-group">
                                <label>
                                    <input type="checkbox" id="countFromEnd">
                                    Считать с конца месяца
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="date-range-group">
                        <div class="form-group">
                            <label>Начало периода</label>
                            <input type="date" id="startDate">
                        </div>

                        <div class="form-group">
                            <label>Конец периода</label>
                            <input type="date" id="endDate">
                        </div>
                    </div>

                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="hideFromCalendar">
                            Не показывать в календаре
                        </label>
                    </div>
                </div>

                <div class="form-actions">
                    <button type="submit" class="btn-primary">Сохранить</button>
                    <button type="button" class="btn-secondary" onclick="closeModal()">Отмена</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        let currentDate = new Date();
        let selectedDate = null;
        let tasks = JSON.parse(localStorage.getItem('tasks') || '[]');
        let editingTaskId = null;
        let activeSlot = { startTime: 0, duration: 1440 };
        let progressUpdateInterval = null;
        
        const savedSettings = JSON.parse(localStorage.getItem('settings'));
        let settings = {
            step: 10,
            theme: 'light-mode',
            notifications: false
        };

        if (savedSettings) {
            settings.step = savedSettings.step || savedSettings.timeStep || 10;
            settings.theme = savedSettings.theme || 'light-mode';
            settings.notifications = savedSettings.notifications || false;
        }
        
        localStorage.setItem('settings', JSON.stringify(settings));

        const monthNames = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 
                          'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'];

        function checkNotifications() {
            if (!settings.notifications) return;
            const now = new Date();
            tasks.forEach(task => {
                if (task.type === 'single' && !task.completed) {
                    const taskDate = new Date(task.date + 'T' + task.time);
                    const diff = taskDate.getTime() - now.getTime();
                    const diffMinutes = Math.round(diff / 60000);

                    // Check for 24 hours (1440 min) and 1 hour (60 min)
                    if (diffMinutes === 1440 || diffMinutes === 60) {
                        new Notification('Напоминание о задаче', {
                            body: `"${task.title}" начнется через ${diffMinutes === 60 ? '1 час' : '24 часа'}.`,
                            tag: `task-notify-${task.id}-${diffMinutes}` // Add a tag to prevent duplicate notifications
                        });
                    }
                }
            });
        }

        function initializeNotifications() {
            const notifyButton = document.getElementById('notifyButton-modal');
            if (!('Notification' in window)) {
                notifyButton.textContent = 'Уведомления не поддерживаются';
                notifyButton.disabled = true;
                return;
            }

            if (Notification.permission === 'granted') {
                settings.notifications = true;
                notifyButton.textContent = 'Уведомления включены';
                notifyButton.disabled = true;
                setInterval(checkNotifications, 60000); // Check every minute
            } else {
                notifyButton.addEventListener('click', () => {
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            settings.notifications = true;
                            notifyButton.textContent = 'Уведомления включены';
                            notifyButton.disabled = true;
                            setInterval(checkNotifications, 60000);
                            alert('Уведомления успешно включены!');
                        } else {
                            alert('Вы не разрешили отправку уведомлений.');
                        }
                    });
                });
            }
        }

        function generateCalendar() {
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const daysInPrevMonth = new Date(year, month, 0).getDate();
            
            document.getElementById('currentMonth').textContent = `${monthNames[month]} ${year}`;
            
            const calendarBody = document.getElementById('calendarBody');
            calendarBody.innerHTML = '';
            
            let date = 1;
            let nextMonthDate = 1;
            
            const adjustedFirstDay = firstDay === 0 ? 6 : firstDay - 1;
            
            for (let i = 0; i < 6; i++) {
                const row = document.createElement('tr');
                
                for (let j = 0; j < 7; j++) {
                    const cell = document.createElement('td');
                    
                    if (i === 0 && j < adjustedFirstDay) {
                        const prevDate = daysInPrevMonth - adjustedFirstDay + j + 1;
                        cell.classList.add('other-month');
                        cell.innerHTML = `<div class="day-number">${prevDate}</div>`;
                    } else if (date > daysInMonth) {
                        cell.classList.add('other-month');
                        cell.innerHTML = `<div class="day-number">${nextMonthDate}</div>`;
                        nextMonthDate++;
                    } else {
                        const currentDateObj = new Date(year, month, date);
                        const today = new Date();
                        
                        if (year === today.getFullYear() && month === today.getMonth() && date === today.getDate()) {
                            cell.classList.add('today');
                        }
                        
                        cell.innerHTML = `<div class="day-number">${date}</div>`;
                        cell.dataset.date = `${year}-${(month + 1).toString().padStart(2, '0')}-${date.toString().padStart(2, '0')}`;
                        cell.onclick = () => selectDate(cell.dataset.date);
                        
                        const tasksForDay = getTasksForDate(currentDateObj, false);
                        const freeMinutes = calculateFreeMinutesForDay(currentDateObj);
                        const freeHours = Math.floor(freeMinutes / 60);

                        if (freeHours >= 1) {
                            const freeHoursDiv = document.createElement('div');
                            freeHoursDiv.className = 'free-hours';
                            freeHoursDiv.textContent = `${freeHours}h`;
                            cell.appendChild(freeHoursDiv);
                        }

                        if (freeHours < 2) {
                            cell.classList.add('low-availability');
                        } else if (freeHours < 4) {
                            cell.classList.add('medium-availability');
                        }

                        if (tasksForDay.length > 0) {
                            const tasksContainer = document.createElement('div');
                            tasksForDay.slice(0, 2).forEach(task => {
                                const taskElement = document.createElement('div');
                                taskElement.className = 'calendar-task';
                                taskElement.textContent = task.title;
                                tasksContainer.appendChild(taskElement);
                            });
                            cell.appendChild(tasksContainer);
                        }
                        
                        date++;
                    }
                    
                    row.appendChild(cell);
                }
                
                calendarBody.appendChild(row);
                if (date > daysInMonth) break;
            }
        }

        function getTasksForDate(date, includeHidden = false) {
            const dateStr = formatDate(date);
            const allTasks = [];
            
            tasks.forEach(task => {
                if (task.type === 'single' && task.date === dateStr) {
                    allTasks.push(task);
                } else if (task.type === 'recurring' && isTaskActiveOnDate(task, date)) {
                    if (includeHidden || !task.hideFromCalendar) {
                        allTasks.push(task);
                    }
                }
            });
            
            return allTasks.sort((a, b) => a.time.localeCompare(b.time));
        }

        function isTaskActiveOnDate(task, date) {
            const startDate = new Date(task.startDate + 'T00:00:00');
            const endDate = task.endDate ? new Date(task.endDate + 'T00:00:00') : null;
            
            if (date < startDate || (endDate && date > endDate)) {
                return false;
            }
            
            if (task.recurringType === 'daily') {
                return true;
            } else if (task.recurringType === 'weekly') {
                const dayOfWeek = date.getDay();
                return task.weekdays && task.weekdays.includes(dayOfWeek.toString());
            } else if (task.recurringType === 'monthly') {
                // Handle new format (comma-separated string)
                if (task.monthDays) {
                    const daysInMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
                    const monthDays = task.monthDays.split(',').map(d => parseInt(d.trim())).filter(d => !isNaN(d));

                    if (task.countFromEnd) {
                        const targetDays = monthDays.map(d => daysInMonth - d + 1);
                        return targetDays.includes(date.getDate());
                    } else {
                        return monthDays.includes(date.getDate());
                    }
                } 
                // Handle old format (single number) for backward compatibility
                else if (task.monthDay) {
                    return date.getDate() === task.monthDay;
                }
                return false; // If neither is present, it's not active
            }
            
            return false;
        }

        function formatDate(date) {
            return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;
        }

        function selectDate(dateStr) {
            selectedDate = dateStr;
            
            document.querySelectorAll('.calendar td').forEach(td => {
                td.classList.remove('selected');
            });
            
            const selectedTd = document.querySelector(`[data-date="${dateStr}"]`);
            if (selectedTd) {
                selectedTd.classList.add('selected');
            }
            
            const [year, month, day] = dateStr.split('-').map(Number);
            const date = new Date(year, month - 1, day);
            const dayNames = ['воскресенье', 'понедельник', 'вторник', 'среда', 'четверг', 'пятница', 'суббота'];
            
            document.getElementById('selectedDate').textContent = 
                `${day} ${monthNames[month - 1]} ${year}, ${dayNames[date.getDay()]}`;
            
            displayTasksForDay(date);

            if (progressUpdateInterval) {
                clearInterval(progressUpdateInterval);
                progressUpdateInterval = null;
            }

            if (formatDate(date) === formatDate(new Date())) {
                progressUpdateInterval = setInterval(() => {
                    displayTasksForDay(date);
                }, 60000); // Update every minute
            }
        }

        function timeToMinutes(timeString) {
            const [hours, minutes] = timeString.split(':').map(Number);
            return hours * 60 + minutes;
        }

        function minutesToTime(totalMinutes) {
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
        }

        function formatDuration(minutes) {
            if (!minutes || minutes < 0) return '';
            const h = Math.floor(minutes / 60);
            const m = minutes % 60;
            let result = '';
            if (h > 0) result += `${h} ч `;
            if (m > 0) result += `${m} мин`;
            return `${result.trim()}`;
        }

        function formatDurationLabel(minutes) {
            const h = Math.floor(minutes / 60);
            const m = minutes % 60;
            let result = '';
            if (h > 0) result += `${h} ч `;
            if (m > 0) result += `${m} мин`;
            return result.trim() || '0 мин';
        }

        function calculateFreeMinutesForDay(date) {
            const tasksForDay = getTasksForDate(date, true);
            let freeMinutes = 0;
            let currentTime = 0;

            tasksForDay.forEach(task => {
                const taskStartTime = timeToMinutes(task.time);
                if (taskStartTime > currentTime) {
                    freeMinutes += taskStartTime - currentTime;
                }
                currentTime = taskStartTime + parseInt(task.duration);
            });

            const endOfDay = 24 * 60; // 23:59 in minutes
            if (endOfDay > currentTime) {
                freeMinutes += endOfDay - currentTime;
            }

            return freeMinutes;
        }

        function displayTasksForDay(date) {
            const tasksForDay = getTasksForDate(date, true); // Включаем скрытые задачи
            const taskList = document.getElementById('taskList');
            taskList.innerHTML = '';

            let currentTime = 0; // Minutes from midnight

            tasksForDay.forEach(task => {
                const taskStartTime = timeToMinutes(task.time);
                const taskEndTime = taskStartTime + parseInt(task.duration);

                // Calculate and display gap before the current task
                if (taskStartTime > currentTime) {
                    const gap = taskStartTime - currentTime;
                    const gapStartTime = currentTime;
                    const liGap = document.createElement('li');
                    liGap.className = 'time-gap';
                    liGap.innerHTML = `
                        <div class="gap-info">
                            Свободно: ${formatDuration(gap)}
                        </div>
                    `;
                    liGap.onclick = () => showAddTaskModalWithTime(minutesToTime(gapStartTime), gap);
                    taskList.appendChild(liGap);
                }

                const li = document.createElement('li');
                li.className = `task-item ${task.type === 'recurring' ? 'recurring' : ''} ${task.completed ? 'completed' : ''}`;
                
                let taskInfo = `
                    <div class="task-time">${task.time} ${formatDuration(task.duration)}</div>
                    <div class="task-title">${task.title}</div>
                `;
                
                if (task.description) {
                    taskInfo += `<div style="font-size: 14px; color: #7f8c8d; margin-top: 4px;">${task.description}</div>`;
                }

                const isToday = formatDate(date) === formatDate(new Date());
                if (isToday && task.type === 'single' && !task.completed) {
                    const now = new Date();
                    const nowMinutes = now.getHours() * 60 + now.getMinutes();
                    const taskStartMinutes = timeToMinutes(task.time);
                    const taskEndMinutes = taskStartMinutes + parseInt(task.duration);

                    if (nowMinutes >= taskStartMinutes && nowMinutes < taskEndMinutes) {
                        const elapsed = nowMinutes - taskStartMinutes;
                        const progress = Math.round((elapsed / parseInt(task.duration)) * 100);
                        taskInfo += `<div class="task-progress-text">${progress}%</div>`;
                    }
                }
                
                taskInfo += `
                    <div class="task-actions">
                        <button onclick="editTask('${task.id}')">Редактировать</button>
                        <button class="delete" onclick="deleteTask('${task.id}')">Удалить</button>
                        ${task.type === 'single' && !task.completed ? `<button class="complete" onclick="completeTask('${task.id}')">Завершить</button>` : ''}
                    </div>
                `;
                
                li.innerHTML = taskInfo;
                taskList.appendChild(li);

                currentTime = taskEndTime;
            });

            // Calculate and display gap after the last task until end of day (23:59)
            const endOfDay = 24 * 60; // 23:59 in minutes
            if (endOfDay > currentTime) {
                const gap = endOfDay - currentTime;
                const liGap = document.createElement('li');
                liGap.className = 'time-gap';
                liGap.innerHTML = `
                    <div class="gap-info">
                        Свободно: ${formatDuration(gap)}
                    </div>
                `;
                liGap.onclick = () => showAddTaskModalWithTime(minutesToTime(currentTime), gap);
                taskList.appendChild(liGap);
            }
        }

        function changeMonth(direction) {
            currentDate.setMonth(currentDate.getMonth() + direction);
            generateCalendar();
            
            if (selectedDate) {
                const [year, month] = selectedDate.split('-').map(Number);
                if (year === currentDate.getFullYear() && month === currentDate.getMonth() + 1) {
                    selectDate(selectedDate);
                }
            }
        }

        function showAddTaskModalWithTime(time, duration) {
            if (!selectedDate) {
                alert('Пожалуйста, выберите день в календаре');
                return;
            }

            activeSlot.startTime = timeToMinutes(time);
            activeSlot.duration = duration;

            editingTaskId = null;
            document.getElementById('modalTitle').textContent = 'Новое дело';
            document.getElementById('taskForm').reset();
            document.getElementById('taskDate').value = selectedDate;

            const taskTime = document.getElementById('taskTime');
            taskTime.min = activeSlot.startTime;
            taskTime.max = activeSlot.startTime + activeSlot.duration - 10;
            taskTime.value = activeSlot.startTime;
            document.getElementById('timeLabel').textContent = minutesToTime(activeSlot.startTime);

            const taskDuration = document.getElementById('taskDuration');
            taskDuration.max = activeSlot.duration;
            taskDuration.value = duration;
            document.getElementById('durationLabel').textContent = formatDurationLabel(duration);

            document.getElementById('taskRecurring').checked = false;
            document.getElementById('taskModal').style.display = 'flex';
            toggleRecurringOptions();
            setDefaultDates();
        }

        function showAddTaskModal() {
            if (!selectedDate) {
                alert('Пожалуйста, выберите день в календаре');
                return;
            }
            
            editingTaskId = null;
            document.getElementById('modalTitle').textContent = 'Новое дело';
            document.getElementById('taskForm').reset();
            document.getElementById('taskDate').value = selectedDate;
            document.getElementById('taskTime').value = 0;
            document.getElementById('timeLabel').textContent = '00:00';
            document.getElementById('taskRecurring').checked = false; // Сброс чекбокса
            document.getElementById('taskModal').style.display = 'flex';
            toggleRecurringOptions();
            setDefaultDates();
        }

        function editTask(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;

            activeSlot.startTime = 0; // Reset for editing
            activeSlot.duration = 1440;
            
            editingTaskId = taskId;
            document.getElementById('modalTitle').textContent = 'Редактировать дело';
            
            
            document.getElementById('taskTitle').value = task.title;

            const taskTime = document.getElementById('taskTime');
            taskTime.min = 0;
            taskTime.max = 1430;
            taskTime.value = timeToMinutes(task.time);
            document.getElementById('timeLabel').textContent = task.time;

            const taskDuration = document.getElementById('taskDuration');
            taskDuration.max = 600; // Reset to a reasonable max
            taskDuration.value = task.duration || 30;
            document.getElementById('durationLabel').textContent = formatDurationLabel(task.duration || 30);

            document.getElementById('taskDescription').value = task.description || '';
            document.getElementById('taskRecurring').checked = (task.type === 'recurring');
            
            if (task.type === 'single') {
                document.getElementById('taskDate').value = task.date;
            } else {
                document.getElementById('recurringType').value = task.recurringType;
                document.getElementById('startDate').value = task.startDate;
                document.getElementById('endDate').value = task.endDate || '';
                document.getElementById('hideFromCalendar').checked = task.hideFromCalendar || false;
                
                if (task.recurringType === 'weekly') {
                    document.querySelectorAll('.weekdays-selector input').forEach(cb => {
                        cb.checked = task.weekdays.includes(cb.value);
                    });
                } else if (task.recurringType === 'monthly') {
                    document.getElementById('monthDays').value = task.monthDays || (task.monthDay ? task.monthDay.toString() : '1');
                    document.getElementById('countFromEnd').checked = task.countFromEnd || false;
                }
            }
            
            toggleRecurringOptions();
            toggleRecurringDetails();
            document.getElementById('taskModal').style.display = 'flex';
        }

        function completeTask(taskId) {
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex !== -1) {
                tasks[taskIndex].completed = true;
                saveTasks();
                if (selectedDate) {
                    displayTasksForDay(new Date(selectedDate));
                }
            }
        }

        function deleteTask(taskId) {
            if (confirm('Вы уверены, что хотите удалить это дело?')) {
                tasks = tasks.filter(t => t.id !== taskId);
                saveTasks();
                generateCalendar();
                if (selectedDate) {
                    selectDate(selectedDate);
                }
            }
        }

        function setDefaultDates() {
            const today = new Date();
            const lastDayOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);

            document.getElementById('startDate').value = formatDate(today);
            document.getElementById('endDate').value = formatDate(lastDayOfMonth);
        }

        function toggleRecurringOptions() {
            const isRecurring = document.getElementById('taskRecurring').checked;
            const recurringOptions = document.getElementById('recurringOptions');
            const singleDateGroup = document.getElementById('singleDateGroup');
            
            if (isRecurring) {
                recurringOptions.style.display = 'block';
                singleDateGroup.style.display = 'none';
            } else {
                recurringOptions.style.display = 'none';
                // Показывать поле даты только при редактировании существующей задачи
                if (editingTaskId) {
                    singleDateGroup.style.display = 'block';
                } else {
                    singleDateGroup.style.display = 'none';
                }
            }
        }

        function toggleRecurringDetails() {
            const recurringType = document.getElementById('recurringType').value;
            document.getElementById('weeklyOptions').style.display = 
                recurringType === 'weekly' ? 'block' : 'none';
            document.getElementById('monthlyOptions').style.display = 
                recurringType === 'monthly' ? 'block' : 'none';
        }

        function closeModal() {
            document.getElementById('taskModal').style.display = 'none';
        }

        function closeSettingsModal() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        function checkOverlap(task) {
            const newStartTime = timeToMinutes(task.time);
            const newEndTime = newStartTime + parseInt(task.duration);
            const overlappingTasks = [];

            for (const existingTask of tasks) {
                if (task.id === existingTask.id) {
                    continue; // Don't compare a task with itself
                }

                const existingStartTime = timeToMinutes(existingTask.time);
                const existingEndTime = existingStartTime + parseInt(existingTask.duration);

                const overlap = (newStartTime < existingEndTime && newEndTime > existingStartTime);

                if (task.type === 'single' && existingTask.type === 'single') {
                    if (task.date === existingTask.date && overlap) {
                        overlappingTasks.push(existingTask);
                    }
                } else if (task.type === 'single' && existingTask.type === 'recurring') {
                    const taskDate = new Date(task.date);
                    if (isTaskActiveOnDate(existingTask, taskDate) && overlap) {
                        overlappingTasks.push(existingTask);
                    }
                } else if (task.type === 'recurring' && existingTask.type === 'single') {
                    const existingTaskDate = new Date(existingTask.date);
                    if (isTaskActiveOnDate(task, existingTaskDate) && overlap) {
                        overlappingTasks.push(existingTask);
                    }
                } else if (task.type === 'recurring' && existingTask.type === 'recurring') {
                    const start = new Date(Math.max(new Date(task.startDate + 'T00:00:00').getTime(), new Date(existingTask.startDate + 'T00:00:00').getTime()));
                    const end = new Date(Math.min(new Date((task.endDate || '9999-12-31') + 'T00:00:00').getTime(), new Date((existingTask.endDate || '9999-12-31') + 'T00:00:00').getTime()));

                    for (let d = start; d <= end; d.setDate(d.getDate() + 1)) {
                        if (isTaskActiveOnDate(task, d) && isTaskActiveOnDate(existingTask, d) && overlap) {
                            overlappingTasks.push(existingTask);
                            break; // Found an overlap for this task, no need to check further dates
                        }
                    }
                }
            }
            return overlappingTasks;
        }

        function saveTasks() {
            localStorage.setItem('tasks', JSON.stringify(tasks));
        }
        
        function loadTasks() {
            tasks = JSON.parse(localStorage.getItem('tasks') || '[]');
        }

        function saveSettings() {
            settings.step = parseInt(document.querySelector('input[name="step"]:checked').value);
            settings.theme = document.getElementById('theme-toggle-modal').checked ? 'dark-mode' : 'light-mode';
            localStorage.setItem('settings', JSON.stringify(settings));
            applySettings();
        }

        function applySettings() {
            document.getElementById('taskTime').step = settings.step;
            document.getElementById('taskDuration').step = settings.step;
            document.getElementById('taskDuration').min = settings.step;
            if (settings.theme === 'dark-mode') {
                document.documentElement.classList.add('dark-mode');
            } else {
                document.documentElement.classList.remove('dark-mode');
            }
            document.getElementById('theme-toggle-modal').checked = settings.theme === 'dark-mode';
            const stepRadio = document.querySelector(`input[name="step"][value="${settings.step}"]`);
            if (stepRadio) {
                stepRadio.checked = true;
            }
        }

        document.getElementById('taskForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const isRecurring = document.getElementById('taskRecurring').checked;
            const title = document.getElementById('taskTitle').value;
            const time = minutesToTime(document.getElementById('taskTime').value);
            const duration = document.getElementById('taskDuration').value;
            const description = document.getElementById('taskDescription').value;
            
            if (!title || !time) {
                alert('Пожалуйста, заполните обязательные поля');
                return;
            }
            
            const taskData = {
                id: editingTaskId || Date.now().toString(),
                type: isRecurring ? 'recurring' : 'single',
                title: title,
                time: time,
                duration: duration,
                description: description
            };
            
            if (taskData.type === 'single') {
                taskData.date = document.getElementById('taskDate').value;
            } else {
                taskData.recurringType = document.getElementById('recurringType').value;
                taskData.startDate = document.getElementById('startDate').value || formatDate(new Date());
                taskData.endDate = document.getElementById('endDate').value;
                taskData.hideFromCalendar = document.getElementById('hideFromCalendar').checked;
                
                if (taskData.recurringType === 'weekly') {
                    taskData.weekdays = Array.from(document.querySelectorAll('.weekdays-selector input:checked'))
                        .map(cb => cb.value);
                } else if (taskData.recurringType === 'monthly') {
                    taskData.monthDays = document.getElementById('monthDays').value;
                    taskData.countFromEnd = document.getElementById('countFromEnd').checked;
                    delete taskData.monthDay; // Remove old property
                }
            }
            
            const overlappingTasks = checkOverlap(taskData);
            if (overlappingTasks.length > 0) {
                const taskTitles = overlappingTasks.map(t => t.title).join(', ');
                alert(`Задача пересекается со следующими задачами: ${taskTitles}`);
                return;
            }
            
            if (editingTaskId) {
                const index = tasks.findIndex(t => t.id === editingTaskId);
                tasks[index] = taskData;
            } else {
                tasks.push(taskData);
            }
            
            saveTasks();
            generateCalendar();
            if (selectedDate) {
                selectDate(selectedDate);
            }
            closeModal();
        });

        // Закрытие модального окна при клике вне его
        document.getElementById('taskModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeModal();
            }
        });

        document.getElementById('settingsModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeSettingsModal();
            }
        });

        document.getElementById('settings-btn').addEventListener('click', () => {
            document.getElementById('theme-toggle-modal').checked = settings.theme === 'dark-mode';
            const stepRadio = document.querySelector(`input[name="step"][value="${settings.step}"]`);
            if (stepRadio) {
                stepRadio.checked = true;
            }
            document.getElementById('settingsModal').style.display = 'flex';
        });

        document.querySelectorAll('input[name="step"]').forEach(radio => {
            radio.addEventListener('change', saveSettings);
        });
        document.getElementById('theme-toggle-modal').addEventListener('change', saveSettings);

        document.getElementById('export-btn').addEventListener('click', () => {
            const data = {
                tasks: tasks,
                settings: settings
            };
            const dataStr = JSON.stringify(data, null, 2);
            const blob = new Blob([dataStr], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'tasks-backup.json';
            a.click();
            URL.revokeObjectURL(url);
        });

        document.getElementById('import-btn').addEventListener('click', () => {
            document.getElementById('import-file').click();
        });

        document.getElementById('import-file').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.tasks && data.settings) {
                        tasks = data.tasks;
                        settings = data.settings;
                        saveTasks();
                        localStorage.setItem('settings', JSON.stringify(settings));
                        applySettings();
                        generateCalendar();
                        if (selectedDate) {
                            selectDate(selectedDate);
                        }
                        alert('Данные успешно импортированы!');
                    } else {
                        alert('Неверный формат файла.');
                    }
                } catch (error) {
                    alert('Ошибка при чтении файла.');
                }
            };
            reader.readAsText(file);
        });

        document.getElementById('taskDuration').addEventListener('input', function(e) {
            document.getElementById('durationLabel').textContent = formatDurationLabel(e.target.value);
        });

        document.getElementById('taskTime').addEventListener('input', function(e) {
            const selectedTime = parseInt(e.target.value);
            document.getElementById('timeLabel').textContent = minutesToTime(selectedTime);

            const taskDuration = document.getElementById('taskDuration');
            const maxDuration = activeSlot.startTime + activeSlot.duration - selectedTime;
            taskDuration.max = maxDuration;

            if (parseInt(taskDuration.value) > maxDuration) {
                taskDuration.value = maxDuration;
            }
            document.getElementById('durationLabel').textContent = formatDurationLabel(taskDuration.value);
        });

        // Инициализация
        document.addEventListener('DOMContentLoaded', () => {
            generateCalendar();
            initializeNotifications();
            applySettings();
            
            // Автоматически выбираем текущий день
            const today = new Date();
            const todayStr = formatDate(today);
            selectDate(todayStr);
        });

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js').then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }

        let deferredPrompt;
        const installButton = document.getElementById('installPwaButton');

        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            installButton.style.display = 'block';

            installButton.addEventListener('click', () => {
                installButton.style.display = 'none';
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('User accepted the A2HS prompt');
                    } else {
                        console.log('User dismissed the A2HS prompt');
                    }
                    deferredPrompt = null;
                });
            });
        });
    </script>
</body>
</html>
