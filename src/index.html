<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫</title>
    <link rel="manifest" href="manifest.json">
    <link rel="stylesheet" href="style.css">
    <script>
        // Apply theme before page loads
        const theme = localStorage.getItem('theme');
        if (theme === 'dark-mode') {
            document.documentElement.classList.add('dark-mode');
        }
    </script>
</head>
<body>
    <div class="header-container">
        <div class="container">
            <div class="header">
                <h1>–ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫</h1>
                <div class="controls">
                    <button id="installPwaButton" style="display: none;">–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>
                    <button id="view-mode-btn" class="view-mode-button" title="–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Ä–µ–∂–∏–º –ø—Ä–æ—Å–º–æ—Ç—Ä–∞">üìÖ</button>
                    <button id="info-btn" class="info-button" title="–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è">‚ÑπÔ∏è</button>
                    <button id="settings-btn" class="settings-button">‚öôÔ∏è</button>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="main-content">
            <div class="calendar-section">
                <div class="month-selector">
                    <button onclick="changeMonth(-1)">‚óÑ</button>
                    <h2 id="currentMonth"></h2>
                    <button onclick="changeMonth(1)">‚ñ∫</button>
                </div>
                <table class="calendar" id="calendar">
                    <thead>
                        <tr>
                            <th>–ü–Ω</th>
                            <th>–í—Ç</th>
                            <th>–°—Ä</th>
                            <th>–ß—Ç</th>
                            <th>–ü—Ç</th>
                            <th>–°–±</th>
                            <th>–í—Å</th>
                        </tr>
                    </thead>
                    <tbody id="calendarBody"></tbody>
                </table>
            </div>

            <div class="day-panel">
                <h3 id="selectedDate">–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–Ω—å</h3>
                <ul class="task-list" id="taskList"></ul>
            </div>
            </div>
    </div>

    <div class="modal" id="infoModal">
        <div class="modal-content info-modal-content">
            <h2>–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫</h2>
            <div class="info-content">
                <h3>–û—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏</h3>
                <ul>
                    <li><strong>–í—ã–±–æ—Ä –¥–Ω—è:</strong> –ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ –¥–µ–Ω—å –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä–µ, —á—Ç–æ–±—ã –ø—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∏ —É–ø—Ä–∞–≤–ª—è—Ç—å –¥–µ–ª–∞–º–∏</li>
                    <li><strong>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –¥–µ–ª–∞:</strong> –ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ —Å–≤–æ–±–æ–¥–Ω—ã–π –ø—Ä–æ–º–µ–∂—É—Ç–æ–∫ –≤—Ä–µ–º–µ–Ω–∏ –≤ –ø–∞–Ω–µ–ª–∏ –¥–Ω—è</li>
                    <li><strong>–°–≤–æ–±–æ–¥–Ω—ã–µ —á–∞—Å—ã:</strong> –í –∫–∞–ª–µ–Ω–¥–∞—Ä–µ –ø–æ–∫–∞–∑–∞–Ω—ã —Å–≤–æ–±–æ–¥–Ω—ã–µ —á–∞—Å—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –¥–Ω—è (–∑–µ–ª–µ–Ω—ã–º —Ü–≤–µ—Ç–æ–º)</li>
                    <li><strong>–¶–≤–µ—Ç–æ–≤–∞—è –∏–Ω–¥–∏–∫–∞—Ü–∏—è:</strong>
                        <ul>
                            <li>–ö—Ä–∞—Å–Ω—ã–π —Ñ–æ–Ω - –º–µ–Ω–µ–µ 2 —Å–≤–æ–±–æ–¥–Ω—ã—Ö —á–∞—Å–æ–≤</li>
                            <li>–ñ–µ–ª—Ç—ã–π —Ñ–æ–Ω - –æ—Ç 2 –¥–æ 4 —Å–≤–æ–±–æ–¥–Ω—ã—Ö —á–∞—Å–æ–≤</li>
                            <li>–û–±—ã—á–Ω—ã–π —Ñ–æ–Ω - –±–æ–ª–µ–µ 4 —Å–≤–æ–±–æ–¥–Ω—ã—Ö —á–∞—Å–æ–≤</li>
                        </ul>
                    </li>
                </ul>

                <h3>–†–µ–∂–∏–º—ã –ø—Ä–æ—Å–º–æ—Ç—Ä–∞</h3>
                <ul>
                    <li><strong>üìÜ –ú–µ—Å—è—Ü:</strong> –ü–æ–¥—Ä–æ–±–Ω—ã–π –≤–∏–¥ –æ–¥–Ω–æ–≥–æ –º–µ—Å—è—Ü–∞ —Å –ø–∞–Ω–µ–ª—å—é –¥–µ–ª –¥–Ω—è</li>
                    <li><strong>üìÖ –ì–æ–¥:</strong> –û–±–∑–æ—Ä –≤—Å–µ–≥–æ –≥–æ–¥–∞ - 12 –º–µ—Å—è—Ü–µ–≤ –≤ –æ–¥–Ω–æ–º –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–∏</li>
                </ul>

                <h3>–¢–∏–ø—ã –¥–µ–ª</h3>
                <ul>
                    <li><strong>–û–¥–∏–Ω–æ—á–Ω–æ–µ –¥–µ–ª–æ:</strong> –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é –¥–∞—Ç—É</li>
                    <li><strong>–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –¥–µ–ª–æ:</strong> –ü–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è –µ–∂–µ–¥–Ω–µ–≤–Ω–æ, –ø–æ –¥–Ω—è–º –Ω–µ–¥–µ–ª–∏ –∏–ª–∏ –¥–Ω—è–º –º–µ—Å—è—Ü–∞</li>
                </ul>

                <h3>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h3>
                <ul>
                    <li><strong>–®–∞–≥ –≤—Ä–µ–º–µ–Ω–∏:</strong> –¢–æ—á–Ω–æ—Å—Ç—å –≤—ã–±–æ—Ä–∞ –≤—Ä–µ–º–µ–Ω–∏ (5, 10, 15, 30, 60 –º–∏–Ω—É—Ç)</li>
                    <li><strong>–ß–∞—Å—ã –Ω–∞ –±—ã—Ç–æ–≤—ã–µ –¥–µ–ª–∞:</strong> –£—á–∏—Ç—ã–≤–∞—é—Ç—Å—è –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏</li>
                    <li><strong>–¢—ë–º–Ω–∞—è —Ç–µ–º–∞:</strong> –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ç–µ–º–Ω–æ–π –∏ —Å–≤–µ—Ç–ª–æ–π —Ç–µ–º—ã</li>
                    <li><strong>–≠–∫—Å–ø–æ—Ä—Ç/–ò–º–ø–æ—Ä—Ç:</strong> –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <h2>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h2>
            <br>
            <div class="form-group">
                <label>–®–∞–≥ –≤—ã–±–æ—Ä–∞ –≤—Ä–µ–º–µ–Ω–∏ (–≤ –º–∏–Ω—É—Ç–∞—Ö)</label>
                <div class="radio-group">
                    <label><input type="radio" name="step" value="5"><span>5</span></label>
                    <label><input type="radio" name="step" value="10" checked><span>10</span></label>
                    <label><input type="radio" name="step" value="15"><span>15</span></label>
                    <label><input type="radio" name="step" value="30"><span>30</span></label>
                    <label><input type="radio" name="step" value="60"><span>60</span></label>
                </div>
            </div>
            <div class="form-group">
                <label for="dailyHours">–ß–∞—Å—ã –Ω–∞ –±—ã—Ç–æ–≤—ã–µ –¥–µ–ª–∞ –≤ —Å—É—Ç–∫–∏: <span id="dailyHoursLabel">8</span></label>
                <input type="range" id="dailyHours" min="0" max="24" step="1" value="8" style="width: 100%;">
            </div>
            <div class="form-group">
                <label for="theme-toggle-modal">–¢—ë–º–Ω–∞—è —Ç–µ–º–∞</label>
                <div class="theme-switcher">
                    <label class="switch">
                        <input type="checkbox" id="theme-toggle-modal">
                        <span class="slider round"></span>
                    </label>
                </div>
            </div>
            <div class="form-group">
                <label for="notifyButton-modal">–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è</label>
                <button id="notifyButton-modal">–í–∫–ª—é—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è</button>
            </div>
            <div class="form-group">
                <label>–î–∞–Ω–Ω—ã–µ</label>
                <div class="btn-group">
                    <button id="export-btn">–≠–∫—Å–ø–æ—Ä—Ç</button>
                    <button id="import-btn">–ò–º–ø–æ—Ä—Ç</button>
                    <input type="file" id="import-file" style="display: none;" accept=".json">
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="taskModal">
        <div class="modal-content">
            <h3 id="modalTitle">–ù–æ–≤–æ–µ –¥–µ–ª–æ</h3>
            <form id="taskForm">
                <div class="form-group">
                    <input type="text" id="taskTitle" placeholder="–ó–∞–≥–æ–ª–æ–≤–æ–∫" required>
                </div>

                <div class="form-group">
                    <textarea id="taskDescription" placeholder="–û–ø–∏—Å–∞–Ω–∏–µ"></textarea>
                </div>

                <div class="form-group">
                    <label for="taskTime">–í—Ä–µ–º—è: <span id="timeLabel">00:00</span></label>
                    <input type="range" id="taskTime" min="0" max="1430" step="10" value="0" style="width: 100%;">
                </div>

                <div class="form-group">
                    <label for="taskDuration">–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: <span id="durationLabel">30 –º–∏–Ω</span></label>
                    <input type="range" id="taskDuration" min="10" max="600" step="10" value="30" style="width: 100%;">
                </div>

                <div class="form-group" id="singleDateGroup">
                    <label>–î–∞—Ç–∞</label>
                    <input type="date" id="taskDate">
                </div>

                <div class="form-group">
                    <div>
                        <label>
                            <input type="checkbox" id="taskRecurring" onchange="toggleRecurringOptions()">
                            –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ
                        </label>
                    </div>
                </div>

                <div class="recurring-options" id="recurringOptions">
                    <div class="form-group">
                        <label>–ü–µ—Ä–∏–æ–¥ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è</label>
                        <select id="recurringType" onchange="toggleRecurringDetails()">
                            <option value="daily">–ï–∂–µ–¥–Ω–µ–≤–Ω–æ</option>
                            <option value="weekly">–î–Ω–∏ –Ω–µ–¥–µ–ª–∏</option>
                            <option value="monthly">–î–Ω–∏ –º–µ—Å—è—Ü–∞</option>
                        </select>
                    </div>

                    <div id="weeklyOptions" style="display: none; padding-bottom: 15px;">
                        <div class="weekdays-selector">
                            <label><span>–ü–Ω</span><input type="checkbox" value="1"></label>
                            <label><span>–í—Ç</span><input type="checkbox" value="2"></label>
                            <label><span>–°—Ä</span><input type="checkbox" value="3"></label>
                            <label><span>–ß—Ç</span><input type="checkbox" value="4"></label>
                            <label><span>–ü—Ç</span><input type="checkbox" value="5"></label>
                            <label><span>–°–±</span><input type="checkbox" value="6"></label>
                            <label><span>–í—Å</span><input type="checkbox" value="0"></label>
                        </div>
                    </div>

                    <div id="monthlyOptions" style="display: none;">
                        <div class="monthly-options-grid">
                            <div class="form-group">
                                <label for="monthDays">–î–Ω–∏ –º–µ—Å—è—Ü–∞ (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é)</label>
                                <input type="text" id="monthDays" placeholder="1, 15, 31" value="1">
                            </div>
                            <div class="form-group checkbox-group">
                                <label>
                                    <input type="checkbox" id="countFromEnd">
                                    –°—á–∏—Ç–∞—Ç—å —Å –∫–æ–Ω—Ü–∞ –º–µ—Å—è—Ü–∞
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="date-range-group">
                        <div class="form-group">
                            <label>–ù–∞—á–∞–ª–æ –ø–µ—Ä–∏–æ–¥–∞</label>
                            <input type="date" id="startDate">
                        </div>

                        <div class="form-group">
                            <label>–ö–æ–Ω–µ—Ü –ø–µ—Ä–∏–æ–¥–∞</label>
                            <input type="date" id="endDate">
                        </div>
                    </div>

                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="hideFromCalendar">
                            –ù–µ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä–µ
                        </label>
                    </div>
                </div>

                <div class="form-actions">
                    <button type="submit" class="btn-primary">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                    <button type="button" class="btn-secondary" onclick="closeModal()">–û—Ç–º–µ–Ω–∞</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        let currentDate = new Date();
        let selectedDate = null;
        let tasks = JSON.parse(localStorage.getItem('tasks') || '[]');
        let editingTaskId = null;
        let activeSlot = { startTime: 0, duration: 1440 };
        let progressUpdateInterval = null;
        let viewMode = 'month'; // 'month' or 'year'
        
        const savedSettings = JSON.parse(localStorage.getItem('settings'));
        let settings = {
            step: 10,
            theme: 'light-mode',
            notifications: false,
            dailyHours: 8
        };

        if (savedSettings) {
            settings.step = savedSettings.step || savedSettings.timeStep || 10;
            settings.theme = savedSettings.theme || 'light-mode';
            settings.notifications = savedSettings.notifications || false;
            settings.dailyHours = savedSettings.dailyHours !== undefined ? savedSettings.dailyHours : 8;
        }

        localStorage.setItem('settings', JSON.stringify(settings));

        const monthNames = ['–Ø–Ω–≤–∞—Ä—å', '–§–µ–≤—Ä–∞–ª—å', '–ú–∞—Ä—Ç', '–ê–ø—Ä–µ–ª—å', '–ú–∞–π', '–ò—é–Ω—å', 
                          '–ò—é–ª—å', '–ê–≤–≥—É—Å—Ç', '–°–µ–Ω—Ç—è–±—Ä—å', '–û–∫—Ç—è–±—Ä—å', '–ù–æ—è–±—Ä—å', '–î–µ–∫–∞–±—Ä—å'];

        function checkNotifications() {
            if (!settings.notifications) return;
            const now = new Date();
            tasks.forEach(task => {
                if (task.type === 'single' && !task.completed) {
                    const taskDate = new Date(task.date + 'T' + task.time);
                    const diff = taskDate.getTime() - now.getTime();
                    const diffMinutes = Math.round(diff / 60000);

                    // Check for 24 hours (1440 min) and 1 hour (60 min)
                    if (diffMinutes === 1440 || diffMinutes === 60) {
                        new Notification('–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –æ –∑–∞–¥–∞—á–µ', {
                            body: `"${task.title}" –Ω–∞—á–Ω–µ—Ç—Å—è —á–µ—Ä–µ–∑ ${diffMinutes === 60 ? '1 —á–∞—Å' : '24 —á–∞—Å–∞'}.`,
                            tag: `task-notify-${task.id}-${diffMinutes}` // Add a tag to prevent duplicate notifications
                        });
                    }
                }
            });
        }

        function initializeNotifications() {
            const notifyButton = document.getElementById('notifyButton-modal');
            if (!('Notification' in window)) {
                notifyButton.textContent = '–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è';
                notifyButton.disabled = true;
                return;
            }

            if (Notification.permission === 'granted') {
                settings.notifications = true;
                notifyButton.textContent = '–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤–∫–ª—é—á–µ–Ω—ã';
                notifyButton.disabled = true;
                setInterval(checkNotifications, 60000); // Check every minute
            } else {
                notifyButton.addEventListener('click', () => {
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            settings.notifications = true;
                            notifyButton.textContent = '–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤–∫–ª—é—á–µ–Ω—ã';
                            notifyButton.disabled = true;
                            setInterval(checkNotifications, 60000);
                            alert('–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —É—Å–ø–µ—à–Ω–æ –≤–∫–ª—é—á–µ–Ω—ã!');
                        } else {
                            alert('–í—ã –Ω–µ —Ä–∞–∑—Ä–µ—à–∏–ª–∏ –æ—Ç–ø—Ä–∞–≤–∫—É —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π.');
                        }
                    });
                });
            }
        }

        function generateCalendar() {
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const daysInPrevMonth = new Date(year, month, 0).getDate();
            
            document.getElementById('currentMonth').textContent = `${monthNames[month]} ${year}`;
            
            const calendarBody = document.getElementById('calendarBody');
            calendarBody.innerHTML = '';
            
            let date = 1;
            let nextMonthDate = 1;
            
            const adjustedFirstDay = firstDay === 0 ? 6 : firstDay - 1;
            
            for (let i = 0; i < 6; i++) {
                const row = document.createElement('tr');
                
                for (let j = 0; j < 7; j++) {
                    const cell = document.createElement('td');
                    
                    if (i === 0 && j < adjustedFirstDay) {
                        const prevDate = daysInPrevMonth - adjustedFirstDay + j + 1;
                        cell.classList.add('other-month');
                        cell.innerHTML = `<div class="day-number">${prevDate}</div>`;
                    } else if (date > daysInMonth) {
                        cell.classList.add('other-month');
                        cell.innerHTML = `<div class="day-number">${nextMonthDate}</div>`;
                        nextMonthDate++;
                    } else {
                        const currentDateObj = new Date(year, month, date);
                        const today = new Date();
                        
                        if (year === today.getFullYear() && month === today.getMonth() && date === today.getDate()) {
                            cell.classList.add('today');
                        }
                        
                        cell.innerHTML = `<div class="day-number">${date}</div>`;
                        cell.dataset.date = `${year}-${(month + 1).toString().padStart(2, '0')}-${date.toString().padStart(2, '0')}`;
                        cell.onclick = () => selectDate(cell.dataset.date);
                        
                        const tasksForDay = getTasksForDate(currentDateObj, false);
                        const freeMinutes = calculateFreeMinutesForDay(currentDateObj);
                        const freeHours = Math.floor(freeMinutes / 60);

                        if (freeHours >= 1) {
                            const freeHoursDiv = document.createElement('div');
                            freeHoursDiv.className = 'free-hours';
                            freeHoursDiv.textContent = `${freeHours}h`;
                            cell.appendChild(freeHoursDiv);
                        }

                        if (freeHours < 2) {
                            cell.classList.add('low-availability');
                        } else if (freeHours < 4) {
                            cell.classList.add('medium-availability');
                        }

                        if (tasksForDay.length > 0) {
                            const tasksContainer = document.createElement('div');
                            tasksForDay.slice(0, 2).forEach(task => {
                                const taskElement = document.createElement('div');
                                taskElement.className = 'calendar-task';
                                taskElement.textContent = task.title;
                                tasksContainer.appendChild(taskElement);
                            });
                            cell.appendChild(tasksContainer);
                        }
                        
                        date++;
                    }
                    
                    row.appendChild(cell);
                }
                
                calendarBody.appendChild(row);
                if (date > daysInMonth) break;
            }
        }

        function getTasksForDate(date, includeHidden = false) {
            const dateStr = formatDate(date);
            const allTasks = [];
            
            tasks.forEach(task => {
                if (task.type === 'single' && task.date === dateStr) {
                    allTasks.push(task);
                } else if (task.type === 'recurring' && isTaskActiveOnDate(task, date)) {
                    if (includeHidden || !task.hideFromCalendar) {
                        allTasks.push(task);
                    }
                }
            });
            
            return allTasks.sort((a, b) => a.time.localeCompare(b.time));
        }

        function isTaskActiveOnDate(task, date) {
            const startDate = new Date(task.startDate + 'T00:00:00');
            const endDate = task.endDate ? new Date(task.endDate + 'T00:00:00') : null;
            
            if (date < startDate || (endDate && date > endDate)) {
                return false;
            }
            
            if (task.recurringType === 'daily') {
                return true;
            } else if (task.recurringType === 'weekly') {
                const dayOfWeek = date.getDay();
                return task.weekdays && task.weekdays.includes(dayOfWeek.toString());
            } else if (task.recurringType === 'monthly') {
                // Handle new format (comma-separated string)
                if (task.monthDays) {
                    const daysInMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
                    const monthDays = task.monthDays.split(',').map(d => parseInt(d.trim())).filter(d => !isNaN(d));

                    if (task.countFromEnd) {
                        const targetDays = monthDays.map(d => daysInMonth - d + 1);
                        return targetDays.includes(date.getDate());
                    } else {
                        return monthDays.includes(date.getDate());
                    }
                } 
                // Handle old format (single number) for backward compatibility
                else if (task.monthDay) {
                    return date.getDate() === task.monthDay;
                }
                return false; // If neither is present, it's not active
            }
            
            return false;
        }

        function formatDate(date) {
            return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;
        }

        function selectDate(dateStr) {
            selectedDate = dateStr;
            
            document.querySelectorAll('.calendar td').forEach(td => {
                td.classList.remove('selected');
            });
            
            const selectedTd = document.querySelector(`[data-date="${dateStr}"]`);
            if (selectedTd) {
                selectedTd.classList.add('selected');
            }
            
            const [year, month, day] = dateStr.split('-').map(Number);
            const date = new Date(year, month - 1, day);
            const dayNames = ['–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ', '–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫', '–≤—Ç–æ—Ä–Ω–∏–∫', '—Å—Ä–µ–¥–∞', '—á–µ—Ç–≤–µ—Ä–≥', '–ø—è—Ç–Ω–∏—Ü–∞', '—Å—É–±–±–æ—Ç–∞'];
            
            document.getElementById('selectedDate').textContent = 
                `${day} ${monthNames[month - 1]} ${year}, ${dayNames[date.getDay()]}`;
            
            displayTasksForDay(date);

            if (progressUpdateInterval) {
                clearInterval(progressUpdateInterval);
                progressUpdateInterval = null;
            }

            if (formatDate(date) === formatDate(new Date())) {
                progressUpdateInterval = setInterval(() => {
                    displayTasksForDay(date);
                }, 60000); // Update every minute
            }
        }

        function timeToMinutes(timeString) {
            const [hours, minutes] = timeString.split(':').map(Number);
            return hours * 60 + minutes;
        }

        function minutesToTime(totalMinutes) {
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
        }

        function formatDuration(minutes) {
            if (!minutes || minutes < 0) return '';
            const h = Math.floor(minutes / 60);
            const m = minutes % 60;
            let result = '';
            if (h > 0) result += `${h} —á `;
            if (m > 0) result += `${m} –º–∏–Ω`;
            return `${result.trim()}`;
        }

        function formatDurationLabel(minutes) {
            const h = Math.floor(minutes / 60);
            const m = minutes % 60;
            let result = '';
            if (h > 0) result += `${h} —á `;
            if (m > 0) result += `${m} –º–∏–Ω`;
            return result.trim() || '0 –º–∏–Ω';
        }

        function calculateFreeMinutesForDay(date) {
            const tasksForDay = getTasksForDate(date, true);
            let freeMinutes = 0;
            let currentTime = 0;

            tasksForDay.forEach(task => {
                const taskStartTime = timeToMinutes(task.time);
                if (taskStartTime > currentTime) {
                    freeMinutes += taskStartTime - currentTime;
                }
                currentTime = taskStartTime + parseInt(task.duration);
            });

            const endOfDay = 24 * 60; // 23:59 in minutes
            if (endOfDay > currentTime) {
                freeMinutes += endOfDay - currentTime;
            }

            // –í—ã—á–∏—Ç–∞–µ–º —á–∞—Å—ã –Ω–∞ –±—ã—Ç–æ–≤—ã–µ –¥–µ–ª–∞
            const dailyHoursInMinutes = settings.dailyHours * 60;
            freeMinutes = Math.max(0, freeMinutes - dailyHoursInMinutes);

            return freeMinutes;
        }

        function displayTasksForDay(date) {
            const tasksForDay = getTasksForDate(date, true); // –í–∫–ª—é—á–∞–µ–º —Å–∫—Ä—ã—Ç—ã–µ –∑–∞–¥–∞—á–∏
            const taskList = document.getElementById('taskList');
            taskList.innerHTML = '';

            let currentTime = 0; // Minutes from midnight

            tasksForDay.forEach(task => {
                const taskStartTime = timeToMinutes(task.time);
                const taskEndTime = taskStartTime + parseInt(task.duration);

                // Calculate and display gap before the current task
                if (taskStartTime > currentTime) {
                    const gap = taskStartTime - currentTime;
                    const gapStartTime = currentTime;
                    const liGap = document.createElement('li');
                    liGap.className = 'time-gap';
                    liGap.innerHTML = `
                        <div class="gap-info">
                            –°–≤–æ–±–æ–¥–Ω–æ: ${formatDuration(gap)}
                        </div>
                    `;
                    liGap.onclick = () => showAddTaskModalWithTime(minutesToTime(gapStartTime), gap);
                    taskList.appendChild(liGap);
                }

                const li = document.createElement('li');
                li.className = `task-item ${task.type === 'recurring' ? 'recurring' : ''} ${task.completed ? 'completed' : ''}`;
                
                let taskInfo = `
                    <div class="task-time">${task.time} ${formatDuration(task.duration)}</div>
                    <div class="task-title">${task.title}</div>
                `;
                
                if (task.description) {
                    taskInfo += `<div style="font-size: 14px; color: #7f8c8d; margin-top: 4px;">${task.description}</div>`;
                }

                const isToday = formatDate(date) === formatDate(new Date());
                if (isToday && task.type === 'single' && !task.completed) {
                    const now = new Date();
                    const nowMinutes = now.getHours() * 60 + now.getMinutes();
                    const taskStartMinutes = timeToMinutes(task.time);
                    const taskEndMinutes = taskStartMinutes + parseInt(task.duration);

                    if (nowMinutes >= taskStartMinutes && nowMinutes < taskEndMinutes) {
                        const elapsed = nowMinutes - taskStartMinutes;
                        const progress = Math.round((elapsed / parseInt(task.duration)) * 100);
                        taskInfo += `<div class="task-progress-text">${progress}%</div>`;
                    }
                }
                
                taskInfo += `
                    <div class="task-actions">
                        <button onclick="editTask('${task.id}')">–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å</button>
                        <button class="delete" onclick="deleteTask('${task.id}')">–£–¥–∞–ª–∏—Ç—å</button>
                        ${task.type === 'single' && !task.completed ? `<button class="complete" onclick="completeTask('${task.id}')">–ó–∞–≤–µ—Ä—à–∏—Ç—å</button>` : ''}
                    </div>
                `;
                
                li.innerHTML = taskInfo;
                taskList.appendChild(li);

                currentTime = taskEndTime;
            });

            // Calculate and display gap after the last task until end of day (23:59)
            const endOfDay = 24 * 60; // 23:59 in minutes
            if (endOfDay > currentTime) {
                const gap = endOfDay - currentTime;
                const liGap = document.createElement('li');
                liGap.className = 'time-gap';
                liGap.innerHTML = `
                    <div class="gap-info">
                        –°–≤–æ–±–æ–¥–Ω–æ: ${formatDuration(gap)}
                    </div>
                `;
                liGap.onclick = () => showAddTaskModalWithTime(minutesToTime(currentTime), gap);
                taskList.appendChild(liGap);
            }
        }

        function changeMonth(direction) {
            if (viewMode === 'year') {
                currentDate.setFullYear(currentDate.getFullYear() + direction);
                generateYearCalendar();
            } else {
                currentDate.setMonth(currentDate.getMonth() + direction);
                generateCalendar();

                if (selectedDate) {
                    const [year, month] = selectedDate.split('-').map(Number);
                    if (year === currentDate.getFullYear() && month === currentDate.getMonth() + 1) {
                        selectDate(selectedDate);
                    }
                }
            }
        }

        function toggleViewMode() {
            viewMode = viewMode === 'month' ? 'year' : 'month';
            const mainContent = document.querySelector('.main-content');
            const viewModeBtn = document.getElementById('view-mode-btn');

            if (viewMode === 'year') {
                mainContent.classList.add('year-view');
                viewModeBtn.textContent = 'üìÜ';
                viewModeBtn.title = '–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –Ω–∞ –º–µ—Å—è—Ü';
                generateYearCalendar();
            } else {
                mainContent.classList.remove('year-view');
                viewModeBtn.textContent = 'üìÖ';
                viewModeBtn.title = '–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –Ω–∞ –≥–æ–¥';
                generateCalendar();
                if (selectedDate) {
                    selectDate(selectedDate);
                }
            }
        }

        function generateYearCalendar() {
            const year = currentDate.getFullYear();
            document.getElementById('currentMonth').textContent = `${year}`;

            const calendarBody = document.getElementById('calendarBody');
            calendarBody.innerHTML = '';

            const daysInYear = (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0) ? 366 : 365;
            const daysPerRow = 14;
            let currentDay = new Date(year, 0, 1);
            const today = new Date();

            for (let dayNum = 0; dayNum < daysInYear; dayNum += daysPerRow) {
                const row = document.createElement('tr');

                for (let i = 0; i < daysPerRow && (dayNum + i) < daysInYear; i++) {
                    const dateObj = new Date(year, 0, dayNum + i + 1);
                    const cell = document.createElement('td');

                    const dayOfMonth = dateObj.getDate();
                    const month = dateObj.getMonth();

                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è—à–Ω–∏–π –¥–µ–Ω—å
                    if (dateObj.getFullYear() === today.getFullYear() &&
                        dateObj.getMonth() === today.getMonth() &&
                        dateObj.getDate() === today.getDate()) {
                        cell.classList.add('today');
                    }

                    // –î–µ–Ω—å –∏ –º–µ—Å—è—Ü
                    const dayLabel = dayOfMonth === 1 ? `${dayOfMonth} ${monthNames[month].substring(0, 3)}` : dayOfMonth;
                    cell.innerHTML = `<div class="day-number">${dayLabel}</div>`;

                    // –†–∞—Å—á–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö —á–∞—Å–æ–≤
                    const freeMinutes = calculateFreeMinutesForDay(dateObj);
                    const freeHours = Math.floor(freeMinutes / 60);

                    if (freeHours >= 1) {
                        const freeHoursDiv = document.createElement('div');
                        freeHoursDiv.className = 'free-hours';
                        freeHoursDiv.textContent = `${freeHours}h`;
                        cell.appendChild(freeHoursDiv);
                    }

                    // –¶–≤–µ—Ç–æ–≤–∞—è –∏–Ω–¥–∏–∫–∞—Ü–∏—è
                    if (freeHours < 2) {
                        cell.classList.add('low-availability');
                    } else if (freeHours < 4) {
                        cell.classList.add('medium-availability');
                    }

                    row.appendChild(cell);
                }

                calendarBody.appendChild(row);
            }
        }

        function showAddTaskModalWithTime(time, duration) {
            if (!selectedDate) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –¥–µ–Ω—å –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä–µ');
                return;
            }

            activeSlot.startTime = timeToMinutes(time);
            activeSlot.duration = duration;

            editingTaskId = null;
            document.getElementById('modalTitle').textContent = '–ù–æ–≤–æ–µ –¥–µ–ª–æ';
            document.getElementById('taskForm').reset();
            document.getElementById('taskDate').value = selectedDate;

            const taskTime = document.getElementById('taskTime');
            taskTime.min = activeSlot.startTime;
            taskTime.max = activeSlot.startTime + activeSlot.duration - 10;
            taskTime.value = activeSlot.startTime;
            document.getElementById('timeLabel').textContent = minutesToTime(activeSlot.startTime);

            const taskDuration = document.getElementById('taskDuration');
            taskDuration.max = activeSlot.duration;
            taskDuration.value = duration;
            document.getElementById('durationLabel').textContent = formatDurationLabel(duration);

            document.getElementById('taskRecurring').checked = false;
            document.getElementById('taskModal').style.display = 'flex';
            toggleRecurringOptions();
            setDefaultDates();
        }

        function showAddTaskModal() {
            if (!selectedDate) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –¥–µ–Ω—å –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä–µ');
                return;
            }
            
            editingTaskId = null;
            document.getElementById('modalTitle').textContent = '–ù–æ–≤–æ–µ –¥–µ–ª–æ';
            document.getElementById('taskForm').reset();
            document.getElementById('taskDate').value = selectedDate;
            document.getElementById('taskTime').value = 0;
            document.getElementById('timeLabel').textContent = '00:00';
            document.getElementById('taskRecurring').checked = false; // –°–±—Ä–æ—Å —á–µ–∫–±–æ–∫—Å–∞
            document.getElementById('taskModal').style.display = 'flex';
            toggleRecurringOptions();
            setDefaultDates();
        }

        function editTask(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;

            activeSlot.startTime = 0; // Reset for editing
            activeSlot.duration = 1440;
            
            editingTaskId = taskId;
            document.getElementById('modalTitle').textContent = '–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –¥–µ–ª–æ';
            
            
            document.getElementById('taskTitle').value = task.title;

            const taskTime = document.getElementById('taskTime');
            taskTime.min = 0;
            taskTime.max = 1430;
            taskTime.value = timeToMinutes(task.time);
            document.getElementById('timeLabel').textContent = task.time;

            const taskDuration = document.getElementById('taskDuration');
            taskDuration.max = 600; // Reset to a reasonable max
            taskDuration.value = task.duration || 30;
            document.getElementById('durationLabel').textContent = formatDurationLabel(task.duration || 30);

            document.getElementById('taskDescription').value = task.description || '';
            document.getElementById('taskRecurring').checked = (task.type === 'recurring');
            
            if (task.type === 'single') {
                document.getElementById('taskDate').value = task.date;
            } else {
                document.getElementById('recurringType').value = task.recurringType;
                document.getElementById('startDate').value = task.startDate;
                document.getElementById('endDate').value = task.endDate || '';
                document.getElementById('hideFromCalendar').checked = task.hideFromCalendar || false;
                
                if (task.recurringType === 'weekly') {
                    document.querySelectorAll('.weekdays-selector input').forEach(cb => {
                        cb.checked = task.weekdays.includes(cb.value);
                    });
                } else if (task.recurringType === 'monthly') {
                    document.getElementById('monthDays').value = task.monthDays || (task.monthDay ? task.monthDay.toString() : '1');
                    document.getElementById('countFromEnd').checked = task.countFromEnd || false;
                }
            }
            
            toggleRecurringOptions();
            toggleRecurringDetails();
            document.getElementById('taskModal').style.display = 'flex';
        }

        function completeTask(taskId) {
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex !== -1) {
                tasks[taskIndex].completed = true;
                saveTasks();
                if (selectedDate) {
                    displayTasksForDay(new Date(selectedDate));
                }
            }
        }

        function deleteTask(taskId) {
            if (confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —ç—Ç–æ –¥–µ–ª–æ?')) {
                tasks = tasks.filter(t => t.id !== taskId);
                saveTasks();
                generateCalendar();
                if (selectedDate) {
                    selectDate(selectedDate);
                }
            }
        }

        function setDefaultDates() {
            const today = new Date();
            const lastDayOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);

            document.getElementById('startDate').value = formatDate(today);
            document.getElementById('endDate').value = formatDate(lastDayOfMonth);
        }

        function toggleRecurringOptions() {
            const isRecurring = document.getElementById('taskRecurring').checked;
            const recurringOptions = document.getElementById('recurringOptions');
            const singleDateGroup = document.getElementById('singleDateGroup');
            
            if (isRecurring) {
                recurringOptions.style.display = 'block';
                singleDateGroup.style.display = 'none';
            } else {
                recurringOptions.style.display = 'none';
                // –ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø–æ–ª–µ –¥–∞—Ç—ã —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –∑–∞–¥–∞—á–∏
                if (editingTaskId) {
                    singleDateGroup.style.display = 'block';
                } else {
                    singleDateGroup.style.display = 'none';
                }
            }
        }

        function toggleRecurringDetails() {
            const recurringType = document.getElementById('recurringType').value;
            document.getElementById('weeklyOptions').style.display = 
                recurringType === 'weekly' ? 'block' : 'none';
            document.getElementById('monthlyOptions').style.display = 
                recurringType === 'monthly' ? 'block' : 'none';
        }

        function closeModal() {
            document.getElementById('taskModal').style.display = 'none';
        }

        function closeSettingsModal() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        function closeInfoModal() {
            document.getElementById('infoModal').style.display = 'none';
        }

        function checkOverlap(task) {
            const newStartTime = timeToMinutes(task.time);
            const newEndTime = newStartTime + parseInt(task.duration);
            const overlappingTasks = [];

            for (const existingTask of tasks) {
                if (task.id === existingTask.id) {
                    continue; // Don't compare a task with itself
                }

                const existingStartTime = timeToMinutes(existingTask.time);
                const existingEndTime = existingStartTime + parseInt(existingTask.duration);

                const overlap = (newStartTime < existingEndTime && newEndTime > existingStartTime);

                if (task.type === 'single' && existingTask.type === 'single') {
                    if (task.date === existingTask.date && overlap) {
                        overlappingTasks.push(existingTask);
                    }
                } else if (task.type === 'single' && existingTask.type === 'recurring') {
                    const taskDate = new Date(task.date);
                    if (isTaskActiveOnDate(existingTask, taskDate) && overlap) {
                        overlappingTasks.push(existingTask);
                    }
                } else if (task.type === 'recurring' && existingTask.type === 'single') {
                    const existingTaskDate = new Date(existingTask.date);
                    if (isTaskActiveOnDate(task, existingTaskDate) && overlap) {
                        overlappingTasks.push(existingTask);
                    }
                } else if (task.type === 'recurring' && existingTask.type === 'recurring') {
                    const start = new Date(Math.max(new Date(task.startDate + 'T00:00:00').getTime(), new Date(existingTask.startDate + 'T00:00:00').getTime()));
                    const end = new Date(Math.min(new Date((task.endDate || '9999-12-31') + 'T00:00:00').getTime(), new Date((existingTask.endDate || '9999-12-31') + 'T00:00:00').getTime()));

                    for (let d = start; d <= end; d.setDate(d.getDate() + 1)) {
                        if (isTaskActiveOnDate(task, d) && isTaskActiveOnDate(existingTask, d) && overlap) {
                            overlappingTasks.push(existingTask);
                            break; // Found an overlap for this task, no need to check further dates
                        }
                    }
                }
            }
            return overlappingTasks;
        }

        function saveTasks() {
            localStorage.setItem('tasks', JSON.stringify(tasks));
        }
        
        function loadTasks() {
            tasks = JSON.parse(localStorage.getItem('tasks') || '[]');
        }

        function saveSettings() {
            settings.step = parseInt(document.querySelector('input[name="step"]:checked').value);
            settings.theme = document.getElementById('theme-toggle-modal').checked ? 'dark-mode' : 'light-mode';
            settings.dailyHours = parseInt(document.getElementById('dailyHours').value);
            localStorage.setItem('settings', JSON.stringify(settings));
            applySettings();
        }

        function applySettings() {
            document.getElementById('taskTime').step = settings.step;
            document.getElementById('taskDuration').step = settings.step;
            document.getElementById('taskDuration').min = settings.step;
            if (settings.theme === 'dark-mode') {
                document.documentElement.classList.add('dark-mode');
            } else {
                document.documentElement.classList.remove('dark-mode');
            }
            document.getElementById('theme-toggle-modal').checked = settings.theme === 'dark-mode';
            const stepRadio = document.querySelector(`input[name="step"][value="${settings.step}"]`);
            if (stepRadio) {
                stepRadio.checked = true;
            }
            document.getElementById('dailyHours').value = settings.dailyHours;
            document.getElementById('dailyHoursLabel').textContent = settings.dailyHours;
        }

        document.getElementById('taskForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const isRecurring = document.getElementById('taskRecurring').checked;
            const title = document.getElementById('taskTitle').value;
            const time = minutesToTime(document.getElementById('taskTime').value);
            const duration = document.getElementById('taskDuration').value;
            const description = document.getElementById('taskDescription').value;
            
            if (!title || !time) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è');
                return;
            }
            
            const taskData = {
                id: editingTaskId || Date.now().toString(),
                type: isRecurring ? 'recurring' : 'single',
                title: title,
                time: time,
                duration: duration,
                description: description
            };
            
            if (taskData.type === 'single') {
                taskData.date = document.getElementById('taskDate').value;
            } else {
                taskData.recurringType = document.getElementById('recurringType').value;
                taskData.startDate = document.getElementById('startDate').value || formatDate(new Date());
                taskData.endDate = document.getElementById('endDate').value;
                taskData.hideFromCalendar = document.getElementById('hideFromCalendar').checked;
                
                if (taskData.recurringType === 'weekly') {
                    taskData.weekdays = Array.from(document.querySelectorAll('.weekdays-selector input:checked'))
                        .map(cb => cb.value);
                } else if (taskData.recurringType === 'monthly') {
                    taskData.monthDays = document.getElementById('monthDays').value;
                    taskData.countFromEnd = document.getElementById('countFromEnd').checked;
                    delete taskData.monthDay; // Remove old property
                }
            }
            
            const overlappingTasks = checkOverlap(taskData);
            if (overlappingTasks.length > 0) {
                const taskTitles = overlappingTasks.map(t => t.title).join(', ');
                alert(`–ó–∞–¥–∞—á–∞ –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç—Å—è —Å–æ —Å–ª–µ–¥—É—é—â–∏–º–∏ –∑–∞–¥–∞—á–∞–º–∏: ${taskTitles}`);
                return;
            }
            
            if (editingTaskId) {
                const index = tasks.findIndex(t => t.id === editingTaskId);
                tasks[index] = taskData;
            } else {
                tasks.push(taskData);
            }
            
            saveTasks();
            generateCalendar();
            if (selectedDate) {
                selectDate(selectedDate);
            }
            closeModal();
        });

        // –ó–∞–∫—Ä—ã—Ç–∏–µ –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ –ø—Ä–∏ –∫–ª–∏–∫–µ –≤–Ω–µ –µ–≥–æ
        document.getElementById('taskModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeModal();
            }
        });

        document.getElementById('settingsModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeSettingsModal();
            }
        });

        document.getElementById('infoModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeInfoModal();
            }
        });

        document.getElementById('view-mode-btn').addEventListener('click', toggleViewMode);

        document.getElementById('info-btn').addEventListener('click', () => {
            document.getElementById('infoModal').style.display = 'flex';
        });

        document.getElementById('settings-btn').addEventListener('click', () => {
            document.getElementById('theme-toggle-modal').checked = settings.theme === 'dark-mode';
            const stepRadio = document.querySelector(`input[name="step"][value="${settings.step}"]`);
            if (stepRadio) {
                stepRadio.checked = true;
            }
            document.getElementById('settingsModal').style.display = 'flex';
        });

        document.querySelectorAll('input[name="step"]').forEach(radio => {
            radio.addEventListener('change', saveSettings);
        });

        document.getElementById('dailyHours').addEventListener('input', function(e) {
            document.getElementById('dailyHoursLabel').textContent = e.target.value;
        });

        document.getElementById('dailyHours').addEventListener('change', () => {
            saveSettings();
            if (viewMode === 'year') {
                generateYearCalendar();
            } else {
                generateCalendar();
                if (selectedDate) {
                    selectDate(selectedDate);
                }
            }
        });

        document.getElementById('theme-toggle-modal').addEventListener('change', saveSettings);

        document.getElementById('export-btn').addEventListener('click', () => {
            const data = {
                tasks: tasks,
                settings: settings
            };
            const dataStr = JSON.stringify(data, null, 2);
            const blob = new Blob([dataStr], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'tasks-backup.json';
            a.click();
            URL.revokeObjectURL(url);
        });

        document.getElementById('import-btn').addEventListener('click', () => {
            document.getElementById('import-file').click();
        });

        document.getElementById('import-file').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.tasks && data.settings) {
                        tasks = data.tasks;
                        settings = data.settings;
                        saveTasks();
                        localStorage.setItem('settings', JSON.stringify(settings));
                        applySettings();
                        generateCalendar();
                        if (selectedDate) {
                            selectDate(selectedDate);
                        }
                        alert('–î–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã!');
                    } else {
                        alert('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞.');
                    }
                } catch (error) {
                    alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞.');
                }
            };
            reader.readAsText(file);
        });

        document.getElementById('taskDuration').addEventListener('input', function(e) {
            document.getElementById('durationLabel').textContent = formatDurationLabel(e.target.value);
        });

        document.getElementById('taskTime').addEventListener('input', function(e) {
            const selectedTime = parseInt(e.target.value);
            document.getElementById('timeLabel').textContent = minutesToTime(selectedTime);

            const taskDuration = document.getElementById('taskDuration');
            const maxDuration = activeSlot.startTime + activeSlot.duration - selectedTime;
            taskDuration.max = maxDuration;

            if (parseInt(taskDuration.value) > maxDuration) {
                taskDuration.value = maxDuration;
            }
            document.getElementById('durationLabel').textContent = formatDurationLabel(taskDuration.value);
        });

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        document.addEventListener('DOMContentLoaded', () => {
            generateCalendar();
            initializeNotifications();
            applySettings();
            
            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤—ã–±–∏—Ä–∞–µ–º —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å
            const today = new Date();
            const todayStr = formatDate(today);
            selectDate(todayStr);
        });

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js').then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }

        let deferredPrompt;
        const installButton = document.getElementById('installPwaButton');

        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            installButton.style.display = 'block';

            installButton.addEventListener('click', () => {
                installButton.style.display = 'none';
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('User accepted the A2HS prompt');
                    } else {
                        console.log('User dismissed the A2HS prompt');
                    }
                    deferredPrompt = null;
                });
            });
        });
    </script>
</body>
</html>
